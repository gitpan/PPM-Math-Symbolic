.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::Operator 3"
.TH Math::Symbolic::Operator 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::Operator \- Operators in symbolic calculations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::Symbolic::Operator;
.Ve
.PP
.Vb 1
\&  my $sum = Math::Symbolic::Operator->new('+', $term1, $term2);
.Ve
.PP
.Vb 8
\&  # or:
\&  my $division =
\&    Math::Symbolic::Operator->new(
\&      {
\&        type     => B_DIVISON,
\&        operands => [$term1, $term2],
\&      }
\&    );
.Ve
.PP
.Vb 7
\&  my $derivative =
\&    Math::Symbolic::Operator->new(
\&      {
\&        type     => U_P_DERIVATIVE,
\&        operands => [$term],
\&      }
\&    );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements all Math::Symbolic::Operator objects.
These objects are overloaded in stringification-context to call the
\&\fIto_string()\fR method on the object. In numeric and boolean context, they
evaluate to their numerical representation.
.PP
For a list of supported operators, please refer to the list found below, in the
documentation for the \fInew()\fR constructor.
.PP
Math::Symbolic::Operator inherits from Math::Symbolic::Base.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None.
.SH "CLASS DATA"
.IX Header "CLASS DATA"
Math::Symbolic::Operator contains several class data structures. Usually, you
should not worry about dealing with any of them because they are mostly an
implementation detail, but for the sake of completeness, here's the gist, but
feel free to skip this section of the docs:
.PP
One of these is the \f(CW%Op_Symbols\fR hash that associates operator (and function)
symbols with the corresponding constant as exported by Math::Symbolic or
Math::Symbolic::ExportConstants. (For example, '+' => B_SUM which in turn is
0, if I recall correctly. But I didn't tell you that. Because you're supposed
to use the supplied (inlined and hence fast) constants so I can change their
internal order if I deem it necessary.)
.PP
The array \f(CW@Op_Types\fR associates operator indices (recall those nifty constants?)
with anonymous hash datastructures that contain some info on the operator such
as its arity, the rule used to derive it, its infix string, its prefix string,
and information on how to actually apply it to numbers.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Constructor new"
.IX Subsection "Constructor new"
Expects a hash reference as first argument. That hash's contents
will be treated as key-value pairs of object attributes.
Important attributes are 'type' => \s-1OPERATORTYPE\s0 (use constants as
exported by Math::Symbolic::ExportConstants!) and 'operands=>[op1,op2,...]'.
Where the operands themselves may either be valid Math::Symbolic::* objects
or strings that will be parsed as such.
.PP
Special case: if no hash reference was found, first
argument is assumed to be the operator's symbol and the operator
is assumed to be binary. The following 2 arguments will be treated as
operands. This special case will ignore attempts to clone objects but if
the operands are no valid Math::Symbolic::* objects, they will be sent
through a Math::Symbolic::Parser to construct Math::Symbolic trees.
.PP
Returns a Math::Symbolic::Operator.
.PP
Supported operator symbols: (number of operands and their
function in parens)
.PP
.Vb 21
\&  +                  => sum (2)
\&  -                  => difference (2)
\&  *                  => product (2)
\&  /                  => division (2)
\&  log                => logarithm (2: base, function)
\&  ^                  => exponentiation (2: base, exponent)
\&  neg                => unary minus (1)
\&  partial_derivative => partial derivative (2: function, var)
\&  total_derivative   => total derivative (2: function, var)
\&  sin                => sine (1)
\&  cos                => cosine (1)
\&  tan                => tangent (1)
\&  cot                => cotangent (1)
\&  asin               => arc sine (1)
\&  acos               => arc cosine (1)
\&  atan               => arc tangent (1)
\&  acot               => arc cotangent (1)
\&  sinh               => hyperbolic sine (1)
\&  cosh               => hyperbolic cosine (1)
\&  asinh              => hyperbolic area sine (1)
\&  acosh              => hyperbolic area cosine (1)
.Ve
.Sh "Method arity"
.IX Subsection "Method arity"
Returns the operator's arity as an integer.
.Sh "Method type"
.IX Subsection "Method type"
Optional integer argument that sets the operator's type.
Returns the operator's type as an integer.
.Sh "Method to_string"
.IX Subsection "Method to_string"
Returns a string representation of the operator and its operands.
Optional argument: 'prefix' or 'infix'. Defaults to 'infix'.
.Sh "Method term_type"
.IX Subsection "Method term_type"
Returns the type of the term. ( T_OPERATOR )
.Sh "Method simplify"
.IX Subsection "Method simplify"
Term simpilification.
First argument: Boolean indicating that the tree does not
need to be cloned, but can be restructured instead.
While this is faster, you might not be able to use the old
tree any more.
.PP
Example:
.PP
.Vb 2
\&  my $othertree = $tree->simplify();
\&  # can use $othertree and $tree now.
.Ve
.PP
.Vb 3
\&  my $yetanothertree = $tree->simplify(1);
\&  # must not use $tree any more because its internal
\&  # representation might have been destroyed.
.Ve
.PP
If you want to optimize a routine and you're sure that you
won't need the unsimplified tree any more, go ahead and use
the first parameter. In all other cases, you should go the
safe route.
.Sh "Methods op1 and op2"
.IX Subsection "Methods op1 and op2"
Returns first/second operand of the operator if it exists or undef.
.Sh "Method apply"
.IX Subsection "Method apply"
Applies the operation to its operands' \fIvalue()\fR and returns the result
as a constant (\-object).
.PP
Without arguments, all variables in the tree are required to have a value.
If any don't, the call to \fIapply()\fR returns undef.
.PP
To (temorarily, for this single method call) assign values to
variables in the tree, you may provide key/value pairs of variable names
and values. Instead of passing a list of key/value pairs, you may also pass
a single hash reference containing the variable mappings.
.PP
You usually want to call the \fIvalue()\fR instead of this.
.Sh "Method value"
.IX Subsection "Method value"
\&\fIvalue()\fR evaluates the Math::Symbolic tree to its numeric representation.
.PP
\&\fIvalue()\fR without arguments requires that every variable in the tree contains
a defined value attribute. Please note that this refers to every variable
\&\fIobject\fR, not just every named variable.
.PP
\&\fIvalue()\fR with one argument sets the object's value if you're dealing with
Variables or Constants. In case of operators, a call with one argument will
assume that the argument is a hash reference. (see next paragraph)
.PP
\&\fIvalue()\fR with named arguments (key/value pairs) associates variables in the tree
with the value-arguments if the corresponging key matches the variable name.
(Can one say this any more complicated?) Since version 0.132, an
equivalent and valid syntax is to pass a single hash reference instead of a
list.
.PP
Example: \f(CW$tree\fR\->value(x => 1, y => 2, z => 3, t => 0) assigns the value 1 to
any occurrances of variables of the name \*(L"x\*(R", aso.
.PP
If a variable in the tree has no value set (and no argument of value sets
it temporarily), the call to \fIvalue()\fR returns undef.
.Sh "Method signature"
.IX Subsection "Method signature"
\&\fIsignature()\fR returns a tree's signature.
.PP
In the context of Math::Symbolic, signatures are the list of variables
any given tree depends on. That means the tree \*(L"v*t+x\*(R" depends on the
variables v, t, and x. Thus, applying \fIsignature()\fR on the tree that would
be parsed from above example yields the sorted list ('t', 'v', 'x').
.PP
Constants do not depend on any variables and therefore return the empty list.
Obviously, operators' dependencies vary.
.PP
Math::Symbolic::Variable objects, however, may have a slightly more
involved signature. By convention, Math::Symbolic variables depend on
themselves. That means their signature contains their own name. But they
can also depend on various other variables because variables themselves
can be viewed as placeholders for more compicated terms. For example
in mechanics, the acceleration of a particle depends on its mass and
the sum of all forces acting on it. So the variable 'acceleration' would
have the signature ('acceleration', 'force1', 'force2',..., 'mass', 'time').
.PP
If you're just looking for a list of the names of all variables in the tree,
you should use the \fIexplicit_signature()\fR method instead.
.Sh "Method explicit_signature"
.IX Subsection "Method explicit_signature"
\&\fIexplicit_signature()\fR returns a lexicographically sorted list of
variable names in the tree.
.PP
See also: \fIsignature()\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic
