.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::VectorCalculus 3"
.TH Math::Symbolic::VectorCalculus 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::VectorCalculus \- Symbolically comp. grad, Jacobi matrices etc.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::Symbolic qw/:all/;
\&  use Math::Symbolic::VectorCalculus; # not loaded by Math::Symbolic
.Ve
.PP
.Vb 9
\&  @gradient = grad 'x+y*z';
\&  # or:
\&  $function = parse_from_string('a*b^c');
\&  @gradient = grad $function;
\&  # or:
\&  @signature = qw(x y z);
\&  @gradient = grad 'a*x+b*y+c*z', @signature; # Gradient only for x, y, z
\&  # or:
\&  @gradient = grad $function, @signature;
.Ve
.PP
.Vb 3
\&  # Similar syntax variations as with the gradient:
\&  $divergence = div @functions;
\&  $divergence = div @functions, @signature;
.Ve
.PP
.Vb 3
\&  # Again, similar DWIM syntax variations as with grad:
\&  @rotation = rot @functions;
\&  @rotation = rot @functions, @signature;
.Ve
.PP
.Vb 5
\&  # Signatures always inferred from the functions here:
\&  @matrix = Jacobi @functions;
\&  # $matrix is now array of array references. These hold
\&  # Math::Symbolic trees. Or:
\&  @matrix = Jacobi @functions, @signature;
.Ve
.PP
.Vb 4
\&  # Similar to Jacobi:
\&  @matrix = Hesse $function;
\&  # or:
\&  @matrix = Hesse $function, @signature;
.Ve
.PP
.Vb 3
\&  $wronsky_determinant = WronskyDet @functions, @vars;
\&  # or:
\&  $wronsky_determinant = WronskyDet @functions; # functions of 1 variable
.Ve
.PP
.Vb 3
\&  $differential = TotalDifferential $function;
\&  $differential = TotalDifferential $function, @signature;
\&  $differential = TotalDifferential $function, @signature, @point;
.Ve
.PP
.Vb 2
\&  $dir_deriv = DirectionalDerivative $function, @vector;
\&  $dir_deriv = DirectionalDerivative $function, @vector, @signature;
.Ve
.PP
.Vb 5
\&  $taylor = TaylorPolyTwoDim $function, $var1, $var2, $degree;
\&  $taylor = TaylorPolyTwoDim $function, $var1, $var2,
\&                             $degree, $var1_0, $var2_0; 
\&  # example:
\&  $taylor = TaylorPolyTwoDim 'sin(x)*cos(y)', 'x', 'y', 2;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides several subroutines related to
vector calculus such as computing gradients, divergence, rotation,
and Jacobi/Hesse Matrices of Math::Symbolic trees.
Furthermore it provides means of computing directional derivatives
and the total differential of a scalar function and the
Wronsky Determinant of a set of n scalar functions.
.PP
Please note that the code herein may or may not be refactored into
the OO-interface of the Math::Symbolic module in the future.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.PP
You may choose to have any of the following routines exported to the
calling namespace. ':all' tag exports all of the following:
.PP
.Vb 9
\&  grad
\&  div
\&  rot
\&  Jacobi
\&  Hesse
\&  WronskyDet
\&  TotalDifferential
\&  DirectionalDerivative
\&  TaylorPolyTwoDim
.Ve
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.Sh "grad"
.IX Subsection "grad"
This subroutine computes the gradient of a Math::Symbolic tree representing
a function.
.PP
The gradient of a function f(x1, x2, ..., xn) is defined as the vector:
.PP
.Vb 4
\&  ( df(x1, x2, ..., xn) / d(x1),
\&    df(x1, x2, ..., xn) / d(x2),
\&    ...,
\&    df(x1, x2, ..., xn) / d(xn) )
.Ve
.PP
(These are all partial derivatives.) Any good book on calculus will have
more details on this.
.PP
grad uses prototypes to allow for a variety of usages. In its most basic form,
it accepts only one argument which may either be a Math::Symbolic tree or a
string both of which will be interpreted as the function to compute the
gradient for. Optionally, you may specify a second argument which must
be a (literal) array of Math::Symbolic::Variable objects or valid
Math::Symbolic variable names (strings). These variables will the be used for
the gradient instead of the x1, ..., xn inferred from the function signature.
.Sh "div"
.IX Subsection "div"
This subroutine computes the divergence of a set of Math::Symbolic trees
representing a vectorial function.
.PP
The divergence of a vectorial function
F = (f1(x1, ..., xn), ..., fn(x1, ..., xn)) is defined like follows:
.PP
.Vb 1
\&  sum_from_i=1_to_n( dfi(x1, ..., xn) / dxi )
.Ve
.PP
That is, the sum of all partial derivatives of the i\-th component function
to the i\-th coordinate. See your favourite book on calculus for details.
Obviously, it is important to keep in mind that the number of function
components must be equal to the number of variables/coordinates.
.PP
Similar to grad, div uses prototypes to offer a comfortable interface.
First argument must be a (literal) array of strings and Math::Symbolic trees
which represent the vectorial function's components. If no second argument
is passed, the variables used for computing the divergence will be
inferred from the functions. That means the function signatures will be
joined to form a signature for the vectorial function.
.PP
If the optional second argument is specified, it has to be a (literal)
array of Math::Symbolic::Variable objects and valid variable names (strings).
These will then be interpreted as the list of variables for computing the
divergence.
.Sh "rot"
.IX Subsection "rot"
This subroutine computes the rotation of a set of three Math::Symbolic trees
representing a vectorial function.
.PP
The rotation of a vectorial function
F = (f1(x1, x2, x3), f2(x1, x2, x3), f3(x1, x2, x3)) is defined as the
following vector:
.PP
.Vb 3
\&  ( ( df3/dx2 - df2/dx3 ),
\&    ( df1/dx3 - df3/dx1 ),
\&    ( df2/dx1 - df1/dx2 ) )
.Ve
.PP
Or \*(L"nabla x F\*(R" for short. Again, I have to refer to the literature for
the details on what rotation is. Please note that there have to be
exactly three function components and three coordinates because the cross
product and hence rotation is only defined in three dimensions.
.PP
As with the previously introduced subroutines div and grad, rot
offers a prototyped interface.
First argument must be a (literal) array of strings and Math::Symbolic trees
which represent the vectorial function's components. If no second argument
is passed, the variables used for computing the rotation will be
inferred from the functions. That means the function signatures will be
joined to form a signature for the vectorial function.
.PP
If the optional second argument is specified, it has to be a (literal)
array of Math::Symbolic::Variable objects and valid variable names (strings).
These will then be interpreted as the list of variables for computing the
rotation. (And please excuse my copying the last two paragraphs from above.)
.Sh "Jacobi"
.IX Subsection "Jacobi"
\&\fIJacobi()\fR returns the Jacobi matrix of a given vectorial function.
It expects any number of arguments (strings and/or Math::Symbolic trees)
which will be interpreted as the vectorial function's components.
Variables used for computing the matrix are, by default, inferred from the
combined signature of the components. By specifying a second literal
array of variable names as (second) argument, you may override this
behaviour.
.PP
The Jacobi matrix is the vector of gradient vectors of the vectorial
function's components.
.Sh "Hesse"
.IX Subsection "Hesse"
\&\fIHesse()\fR returns the Hesse matrix of a given scalar function. First
argument must be a string (to be parsed as a Math::Symbolic tree)
or a Math::Symbolic tree. As with \fIJacobi()\fR, \fIHesse()\fR optionally
accepts an array of signature variables as second argument.
.PP
The Hesse matrix is the Jacobi matrix of the gradient of a scalar function.
.Sh "TotalDifferential"
.IX Subsection "TotalDifferential"
This function computes the total differential of a scalar function of
multiple variables in a certain point.
.PP
First argument must be the function to derive. The second argument is
an optional (literal) array of variable names (strings) and
Math::Symbolic::Variable objects to be used for deriving. If the argument
is not specified, the functions signature will be used. The third argument
is also an optional array and denotes the set of variable (names) to use for
indicating the point for which to evaluate the differential. It must have
the same number of elements as the second argument.
If not specified the variable names used as coordinated (the second argument)
with an appended '_0' will be used as the point's components.
.Sh "DirectionalDerivative"
.IX Subsection "DirectionalDerivative"
DirectionalDerivative computes the directional derivative of a scalar function
in the direction of a specified vector. With f being the function and X, A being
vectors, it looks like this: (this is a partial derivative)
.PP
.Vb 1
\&  df(X)/dA = grad(f(X)) * (A / |A|)
.Ve
.PP
First argument must be the function to derive (either a string or a valid
Math::Symbolic tree). Second argument must be vector into whose direction to
derive. It is to be specified as an array of variable names and objects.
Third argument is the optional signature to be used for computing the gradient.
Please see the documentation of the grad function for details. It's
dimension must match that of the directional vector.
.Sh "TaylorPolyTwoDim"
.IX Subsection "TaylorPolyTwoDim"
This subroutine computes the Taylor Polynomial for functions of two
variables. Please refer to the documentation of the TaylorPolynomial
function in the Math::Symbolic::MiscCalculus package for an explanation
of single dimensional Taylor Polynomials. This is the counterpart in
two dimensions.
.PP
First argument must be the function to approximate with the Taylor Polynomial
either as a string or a Math::Symbolic tree. Second and third argument
must be the names of the two coordinates. (These may alternatively be
Math::Symbolic::Variable objects.) Fourth argument must be
the degree of the Taylor Polynomial. Fifth and Sixth arguments are optional
and specify the names of the variables to introduce as the point of
approximation. These default to the names of the coordinates with '_0'
appended.
.Sh "WronskyDet"
.IX Subsection "WronskyDet"
\&\fIWronskyDet()\fR computes the Wronsky Determinant of a set of n functions.
.PP
First argument is required and a (literal) array of n functions. Second
argument is optional and a (literal) array of n variables or variable names.
If the second argument is omitted, the variables used for deriving are inferred
from function signatures. This requires, however, that the function signatures
have exactly one element. (And the function this exactly one variable.)
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic
