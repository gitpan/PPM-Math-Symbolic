.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::MiscAlgebra 3"
.TH Math::Symbolic::MiscAlgebra 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::MiscAlgebra \- Miscellaneous algebra routines like det()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::Symbolic qw/:all/;
\&  use Math::Symbolic::MiscAlgebra qw/:all/; # not loaded by Math::Symbolic
.Ve
.PP
.Vb 2
\&  @matrix = (['x*y', 'z*x', 'y*z'],['x', 'z', 'z'],['x', 'x', 'y']);
\&  $det = det @matrix;
.Ve
.PP
.Vb 2
\&  @vector = ('x', 'y', 'z');
\&  $solution = solve_linear(\e@matrix, \e@vector);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides several subroutines related to
algebra such as computing the determinant of quadratic matrices, solving
linear equation systems and computation of Bell Polynomials.
.PP
Please note that the code herein may or may not be refactored into
the OO-interface of the Math::Symbolic module in the future.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.PP
You may choose to have any of the following routines exported to the
calling namespace. ':all' tag exports all of the following:
.PP
.Vb 3
\&  det
\&  linear_solve
\&  bell_polynomial
.Ve
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.Sh "det"
.IX Subsection "det"
\&\fIdet()\fR computes the determinant of a matrix of Math::Symbolic trees (or strings
that can be parsed as such). First argument must be a literal array:
\&\*(L"det \f(CW@matrix\fR\*(R", where \f(CW@matrix\fR is an n x n matrix.
.PP
Please note that calculating determinants of matrices using the
straightforward Laplace algorithm is a slow (O(n!))
operation. This implementation cannot make use of the various optimizations
resulting from the determinant properties since we are dealing with
symbolic matrix elements. If you have a matrix of reals, it is strongly
suggested that you use Math::MatrixReal or Math::Pari to get the determinant
which can be calculated using \s-1LR\s0 decomposition much faster.
.PP
On a related note: Calculating the determinant of a 20x20 matrix would take
over 77146 years if your Perl could do 1 million calculations per second.
Given that we're talking about several method calls per calculation, that's
much more than todays computers could do. On the other hand, if you'd be
using this straightforward algorithm with numbers only and in C, you might
be done in 26 years alright, so please go for the smarter route (better
algorithm) instead if you have numbers only.
.Sh "linear_solve"
.IX Subsection "linear_solve"
Calculates the solutions x (vector) of a linear equation system of the form
\&\f(CW\*(C`Ax = b\*(C'\fR with \f(CW\*(C`A\*(C'\fR being a matrix, \f(CW\*(C`b\*(C'\fR a vector and the solution \f(CW\*(C`x\*(C'\fR a
vector. Due to implementation limitations, \f(CW\*(C`A\*(C'\fR must be a quadratic matrix and
\&\f(CW\*(C`b\*(C'\fR must have a dimension that is equivalent to that of \f(CW\*(C`A\*(C'\fR. Furthermore,
the determinant of \f(CW\*(C`A\*(C'\fR must be non\-zero. The algorithm used is devised from
Cramer's Rule and thus inefficient. The preferred algorithm for this task is
Gaussian Elimination. If you have a matrix and a vector of real numbers, please
consider using either Math::MatrixReal or Math::Pari instead.
.PP
First argument must be a reference to a matrix (array of arrays) of symbolic
terms, second argument must be a reference to a vector (array) of symbolic
terms. Strings will be automatically converted to Math::Symbolic trees.
Returns a reference to the solution vector.
.Sh "bell_polynomial"
.IX Subsection "bell_polynomial"
This functions returns the nth Bell Polynomial. It uses memoization for
speed increase.
.PP
First argument is the n. Second (optional) argument is the variable or
variable name to use in the polynomial. Defaults to 'x'.
.PP
The Bell Polynomial is defined as follows:
.PP
.Vb 2
\&  phi_0  (x) = 1
\&  phi_n+1(x) = x * ( phi_n(x) + partial_derivative( phi_n(x), x ) )
.Ve
.PP
Bell Polynomials are Exponential Polynimals with \fIphi_n\fR\|(1) = the nth bell
number. Please refer to the \fIbell_number()\fR function in the
Math::Symbolic::AuxFunctions module for a method of generating these numbers.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic
