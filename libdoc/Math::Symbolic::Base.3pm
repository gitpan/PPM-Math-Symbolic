.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::Base 3"
.TH Math::Symbolic::Base 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::Base \- Base class for symbols in symbolic calculations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::Symbolic::Base;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a base class for all Math::Symbolic::* terms such as
Math::Symbolic::Operator, Math::Symbolic::Variable and
Math::Symbolic::Constant objects.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "METHODS"
.IX Header "METHODS"
.Sh "Method to_string"
.IX Subsection "Method to_string"
Default method for stringification just returns the object's value.
.Sh "Method value"
.IX Subsection "Method value"
\&\fIvalue()\fR evaluates the Math::Symbolic tree to its numeric representation.
.PP
\&\fIvalue()\fR without arguments requires that every variable in the tree contains
a defined value attribute. Please note that this refers to every variable
\&\fIobject\fR, not just every named variable.
.PP
\&\fIvalue()\fR with one argument sets the object's value (in case of a variable or
constant).
.PP
\&\fIvalue()\fR with named arguments (key/value pairs) associates variables in the tree
with the value-arguments if the corresponging key matches the variable name.
(Can one say this any more complicated?) Since version 0.132, an alternative
syntax is to pass a single hash reference.
.PP
Example: \f(CW$tree\fR\->value(x => 1, y => 2, z => 3, t => 0) assigns the value 1 to
any occurrances of variables of the name \*(L"x\*(R", aso.
.PP
If a variable in the tree has no value set (and no argument of value sets
it temporarily), the call to \fIvalue()\fR returns undef.
.Sh "Method signature"
.IX Subsection "Method signature"
\&\fIsignature()\fR returns a tree's signature.
.PP
In the context of Math::Symbolic, signatures are the list of variables
any given tree depends on. That means the tree \*(L"v*t+x\*(R" depends on the
variables v, t, and x. Thus, applying \fIsignature()\fR on the tree that would
be parsed from above example yields the sorted list ('t', 'v', 'x').
.PP
Constants do not depend on any variables and therefore return the empty list.
Obviously, operators' dependencies vary.
.PP
Math::Symbolic::Variable objects, however, may have a slightly more
involved signature. By convention, Math::Symbolic variables depend on
themselves. That means their signature contains their own name. But they
can also depend on various other variables because variables themselves
can be viewed as placeholders for more compicated terms. For example
in mechanics, the acceleration of a particle depends on its mass and
the sum of all forces acting on it. So the variable 'acceleration' would
have the signature ('acceleration', 'force1', 'force2',..., 'mass', 'time').
.PP
If you're just looking for a list of the names of all variables in the tree,
you should use the \fIexplicit_signature()\fR method instead.
.Sh "Method explicit_signature"
.IX Subsection "Method explicit_signature"
\&\fIexplicit_signature()\fR returns a lexicographically sorted list of
variable names in the tree.
.PP
See also: \fIsignature()\fR.
.Sh "Method set_signature"
.IX Subsection "Method set_signature"
set_signature expects any number of variable identifiers as arguments.
It sets a variable's signature to this list of identifiers.
.Sh "Method implement"
.IX Subsection "Method implement"
\&\fIimplement()\fR works in\-place!
.PP
Takes key/value pairs as arguments. The keys are to be variable names
and the values must be valid Math::Symbolic trees. All occurrances
of the variables will be replaced with their implementation.
.Sh "Method replace"
.IX Subsection "Method replace"
First argument must be a valid Math::Symbolic tree.
.PP
\&\fIreplace()\fR modifies the object it is called on in-place in that it
replaces it with its first argument. Doing that, it retains the original
object reference. This destroys the object it is called on.
.PP
However, this also means that you can create recursive trees of objects if
the new tree is to contain the old tree. So make sure you clone the old tree
using the \fInew()\fR method before using it in the replacement tree or you will
end up with a program that eats your memory fast.
.Sh "fill_in_vars"
.IX Subsection "fill_in_vars"
This method returns a modified copy of the tree it was called on.
.PP
It walks the tree and replaces all variables whose value attribute is
defined (either done at the time of object creation or using \fIset_value()\fR)
with the corresponding constant objects. Variables whose value is
not defined are unaffected. Take, for example, the following code:
.PP
.Vb 4
\&  $tree = parse_from_string('a*b+a*c');
\&  $tree->set_value(a => 4, c => 10); # value of b still not defined.
\&  print $tree->fill_in_vars();
\&  # prints "(4 * b) + (4 * 10)"
.Ve
.Sh "Method simplify"
.IX Subsection "Method simplify"
Minimum method for term simpilification just clones.
.Sh "Method descending_operands"
.IX Subsection "Method descending_operands"
When called on an operator, descending_operands tries hard to determine
which operands to descend into. (Which usually means all operands.)
A list of these is returned.
.PP
When called on a constant or a variable, it returns the empty list.
.PP
Of course, some routines may have to descend into different branches of the
Math::Symbolic tree, but this routine returns the default operands.
.PP
The first argument to this method may control its behaviour. If it is any of
the following key\-words, behaviour is modified accordingly:
.PP
.Vb 1
\&  default   -- obvious. Use default heuristics.
.Ve
.PP
.Vb 3
\&  These are all supersets of 'default':
\&  all       -- returns ALL operands. Use with caution.
\&  all_vars  -- returns all operands that may contain vars.
.Ve
.Sh "Method descend"
.IX Subsection "Method descend"
The method takes named arguments (key/value pairs).
\&\fIdescend()\fR descends (Who would have guessed?) into the Math::Symbolic tree
recursively and for each node, it calls code references with a copy of
the current node as argument. The copy may be modified and will be used for
construction of the returned tree. The automatic copying behaviour may be
turned off.
.PP
Returns a (modified) copy of the original tree. If in-place modification is
turned on, the returned tree will not be a copy.
.PP
Availlable parameters are:
.IP "before" 2
.IX Item "before"
A code reference to be used as a callback that will be invoked before descent.
Depending on whether or not the \*(L"in_place\*(R" option is set, the callback will
be passed a copy of the current node (default) or the original node itself.
.Sp
The callback may modify the tree node and the modified node will be used to
construct \fIdescend()\fR's return value.
.Sp
The return value of this callback describes the way \fIdescend()\fR handles the
descent into the current node's operands.
.Sp
If it returns the empty list, the (possibly modified) copy of the current
that was passed to the callback is used as the return value of \fIdescend()\fR,
but the recursive descent is continued for all of the current node's operands
which may or may not be modified by the callback. The \*(L"after\*(R" callback will
be called on the node after descent into the operands. (This is the
normal behavior.)
.Sp
If the callback returns undef, the descent is stopped for the current branch
and an exact copy of the current branch's children will be used for
\&\fIdescend()\fR's return value. The \*(L"after\*(R" callback will be called immediately.
.Sp
If the callback returns a list of integers, these numbers are assumed to
be the indexes of the current node's operands that are to be descended into.
That means if the callback returns (1), descend will be called for the
second operand and only the second. All other children/operands will be cloned.
As usual, the \*(L"after\*(R" callback will be called after descent.
.Sp
Any other return lists will lead to hard-to-debug errors. Tough luck.
.Sp
Returning a hash reference from the callback allows for complete control
over the \fIdescend()\fR routine. The hash may contain the following elements:
.RS 2
.IP "operands" 2
.IX Item "operands"
This is a referenced array that will be put in place of the previous
operands. It is the callback's job to make sure the number of operands stays
correct. The \*(L"operands\*(R" entry is evaluated \fIbefore\fR the \*(L"descend_into\*(R"
entry.
.IP "descend_into" 2
.IX Item "descend_into"
This is a referenced array of integers and references. The integers are
assumed to be indices of the array of operands. Returning (1) results in
descent into the second operand and only the second.
.Sp
References are assumed to be operands to descend into. \fIdescend()\fR will be
directly called on them.
.Sp
If the array is empty, \fIdescend()\fR will act just as if
an empty list had been returned.
.IP "in_place" 2
.IX Item "in_place"
Boolean indicating whether or not to modify the operands in-place or not.
If this is true, \fIdescend()\fR will be called with the \*(L"in_place => 1\*(R" parameter.
If false, it will be called with \*(L"in_place => 0\*(R" instead.
Defaults to false. (Cloning)
.Sp
This does not affect the call to the \*(L"after\*(R" callback but only the descent
into operands.
.IP "skip_after" 2
.IX Item "skip_after"
If this option exists and is set to true, the \*(L"after\*(R" callback will not be
invoked. This only applies to the current node, not to its children/operands.
.RE
.RS 2
.Sp
The list of options may grow in future versions.
.RE
.IP "after" 2
.IX Item "after"
This is a code reference which will be invoked as a callback after the descent
into the operands.
.IP "in_place" 2
.IX Item "in_place"
Controls whether or not to modify the current tree node in\-place. Defaults to
false \- cloning.
.IP "operand_finder" 2
.IX Item "operand_finder"
This option controls how the descend routine chooses which operands to
recurse into by default. That means it controls which operands \fIdescend()\fR
recurses into if the 'before' routine returned the empty list or if
no 'before' routine was specified.
.Sp
The option may either be a code reference or a string. If it is a code
reference, this code reference will be called with the current node as
argument. If it is a string, the method with that name will be called
on the current node object.
.Sp
By default, \fIdescend()\fR calls the '\fIdescending_operands()\fR' method on the current
node to determine the operands to descend into.
.Sh "Method term_type"
.IX Subsection "Method term_type"
Returns the type of the term. This is a stub to be overridden.
.Sh "Method set_value"
.IX Subsection "Method set_value"
\&\fIset_value()\fR returns the tree it modifies, but acts in-place on the
Math::Symbolic tree it was called on.
.PP
\&\fIset_value()\fR requires named arguments (key/value pairs) that associate
variable names of variables in the tree with the value-arguments if the
corresponging key matches the variable name.
(Can one say this any more complicated?) Since version 0.132, an alternative
syntax is to pass a single hash reference to the method.
.PP
Example: \f(CW$tree\fR\->set_value(x => 1, y => 2, z => 3, t => 0) assigns the value 1
to any occurrances of variables of the name \*(L"x\*(R", aso.
.PP
As opposed to \fIvalue()\fR, \fIset_value()\fR assigns to the variables \fIpermanently\fR
and does not evaluate the tree.
.PP
When called on constants, \fIset_value()\fR sets their value to its first
argument, but only if there is only one argument.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic
