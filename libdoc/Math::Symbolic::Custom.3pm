.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::Custom 3"
.TH Math::Symbolic::Custom 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::Custom \- Aggregate class for tree tests and transformations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # Extending the class:
\&  package Math::Symbolic::Custom::MyTransformations;
\&  use Math::Symbolic::Custom::Base;
\&  BEGIN {*import = \e&Math::Symbolic::Custom::Base::aggregate_import}
.Ve
.PP
.Vb 5
\&  our $Aggregate_Export = [qw/apply_transformation1 .../];
\&  sub apply_transformation1 {
\&     # ...
\&  }
\&  # ...
.Ve
.PP
.Vb 3
\&  # Using the custom class:
\&  use Math::Symbolic;
\&  use Math::Symbolic::Custom::MyTransformations;
.Ve
.PP
.Vb 7
\&  # later...
\&  $tree->apply_transformation1();
\&  $tree->mod_transformation2();
\&  die unless $tree->is_type1();
\&  die unless $tree->test_condition1();
\&  die if $tree->contains_something1();
\&  print $tree->to_latex();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an aggregate class for all custom modification, transformation,
testing and output extensions for Math::Symbolic trees.
Some default transformations and tests are implemented in the
Math::Symbolic::Custom::DefaultMods and
Math::Symbolic::Custom::DefaultTests packages, default output
routines in Math::Symbolic::Custom::DefaultDumpers which are automatically
loaded by the Math::Symbolic::Custom class.
.PP
Math::Symbolic::Custom imports all constants from
Math::Symbolic::ExportConstants
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "EXTENDING THE MODULE"
.IX Header "EXTENDING THE MODULE"
In order to extend the functionality of Math::Symbolic, you have to go
through the following steps: (also see the synopsis in this document.)
.IP "\(bu" 4
Choose an appropriate namespace in the Math::Symbolic::Custom::*
hierarchy or if you desparately wish, somewhere else.
.IP "\(bu" 4
Create a new module (probably using \*(L"h2xs \-AX \s-1MODULENAME\s0\*(R") and put the
following lines of code in it:
.Sp
.Vb 4
\&  # To make sure we're cooperating with Math::Symbolic's idea of
\&  # method delegation.
\&  use Math::Symbolic::Custom::Base;
\&  BEGIN {*import = \e&Math::Symbolic::Custom::Base::aggregate_import}
.Ve
.Sp
.Vb 3
\&  our $Aggregate_Export = [
\&    # Put the list of method names to be exported.
\&  /];
.Ve
.IP "\(bu" 4
Think well about the naming of your exported methods. Answer the following
questions:
.Sp
Does the name start with 'is_', 'test_', 'mod_', 'apply_', 'contains_',
or 'to_'?
If not, find a suitable name that does.
.Sp
Does the name clash with any of the methods exported by
Math::Symbolic::Custom::DefaultTests, Math::Symbolic::Custom::DefaultMods,
or Math::Symbolic::Custom::DefaultDumpers?
If so, please consider choosing a different name.
.Sp
Does the name map to the idea behind the method prefix ('is_', ...)?
Only methods starting with one of the prefixes listed above can be
delegated. Any others will never be called. The idea behind delegating
methods with several prefixes is to provide for a reasonable
choice for naming methods. 'is_' and 'contains_' are meant to be
used for accurate tests like \*(L"is_constant\*(R". 'test_' is meant for
all tests that either make use of heuristics or can't be fitted into
either 'is_' or 'contains_'. The prefixes 'mod_' and 'apply_' are
meant for use with methods that modify the Math::Symbolic tree.
Finally, the prefix 'to_' is meant to be used with conversion and output
methods like 'to_latex' or 'to_string'. (Though as of version 0.122,
to_string is implemented in the core Math::Symbolic modules.)
.IP "\(bu" 4
Make sure you document exactly what your methods do. Do they modify the
Math::Symbolic tree in-place or do they clone using the \fInew()\fR constructor
and return a copy? Make sure you mention the behaviour in the docs.
.IP "\(bu" 4
Consider packaging your extensions as a \s-1CPAN\s0 distribution to
help others in their development with Math::Symbolic. If you
think the extensions are generic enough to be a worthwhile
addition to the core distribution, try sending your extensions
to the Math::Symbolic developers mailing list instead.
.IP "\(bu" 4
Load your extension module after loading the Math::Symbolic module.
.IP "\(bu" 4
Start using your custom enhancements as methods to the Math::Symbolic
trees (any term types).
.IP "\(bu" 4
Send bug reports and feedback to the Math::Symbolic support mailing list.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic::Custom::Base
Math::Symbolic::Custom::DefaultTests
Math::Symbolic::Custom::DefaultMods
Math::Symbolic::Custom::DefaultDumpers
.PP
Math::Symbolic
