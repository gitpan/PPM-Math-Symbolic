.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Symbolic::MiscCalculus 3"
.TH Math::Symbolic::MiscCalculus 3 "2006-02-14" "perl v5.8.6" "User Contributed Perl Documentation"
.SH "NAME"
Math::Symbolic::MiscCalculus \- Miscellaneous calculus routines (eg Taylor poly)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::Symbolic qw/:all/;
\&  use Math::Symbolic::MiscCalculus qw/:all/; # not loaded by Math::Symbolic
.Ve
.PP
.Vb 3
\&  $taylor_poly = TaylorPolynomial $function, $degree, $variable;
\&  # or:
\&  $taylor_poly = TaylorPolynomial $function, $degree, $variable, $pos;
.Ve
.PP
.Vb 6
\&  $lagrange_error = TaylorErrorLagrange $function, $degree, $variable;
\&  # or:
\&  $lagrange_error = TaylorErrorLagrange $function, $degree, $variable, $pos;
\&  # or:
\&  $lagrange_error = TaylorErrorLagrange $function, $degree, $variable, $pos,
\&                                        $name_for_range_variable;
.Ve
.PP
.Vb 2
\&  # This has the same syntax variations as the Lagrange error:
\&  $cauchy_error = TaylorErrorLagrange $function, $degree, $variable;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides several subroutines related to
calculus such as computing Taylor polynomials and errors the
associated errors from Math::Symbolic trees.
.PP
Please note that the code herein may or may not be refactored into
the OO-interface of the Math::Symbolic module in the future.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.PP
You may choose to have any of the following routines exported to the
calling namespace. ':all' tag exports all of the following:
.PP
.Vb 3
\&  TaylorPolynomial
\&  TaylorErrorLagrange
\&  TaylorErrorCauchy
.Ve
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.Sh "TaylorPolynomial"
.IX Subsection "TaylorPolynomial"
This function (symbolically) computes the nth-degree Taylor Polynomial
of a given function. Generally speaking, the Taylor Polynomial is an
n\-th degree polynomial that approximates the original function. It does
so particularily well in the proximity of a certain point x0.
(Since my mathematical English jargon is lacking, I strongly suggest you
read up on what this is in a book.)
.PP
Mathematically speaking, the Taylor Polynomial of the function f(x) looks
like this:
.PP
.Vb 4
\&  Tn(f, x, x0) =
\&    sum_from_k=0_to_n(
\&        n-th_total_derivative(f)(x0) / k! * (x-x0)^k
\&    )
.Ve
.PP
First argument to the subroutine must be the function to approximate. It may
be given either as a string to be parsed or as a valid Math::Symbolic tree.
Second argument must be an integer indicating to which degree to approximate.
The third argument is the last required argument and denotes the variable
to use for approximation either as a string (name) or as a
Math::Symbolic::Variable object. That's the 'x' above.
The fourth argument is optional and specifies the name of the variable to
introduce as the point of approximation. May also be a variable object.
It's the 'x0' above. If not specified, the name of this variable will be
assumed to be the name of the function variable (the 'x') with '_0' appended.
.PP
This routine is for functions of one variable only. There is an equivalent
for functions of two variables in the Math::Symbolic::VectorCalculus package.
.Sh "TaylorErrorLagrange"
.IX Subsection "TaylorErrorLagrange"
TaylorErrorLagrange computes and returns the formula for the Taylor
Polynomial's approximation error after Lagrange. (Again, my English
terminology is lacking.) It looks similar to this:
.PP
.Vb 2
\&  Rn(f, x, x0) =
\&    n+1-th_total_derivative(f)( x0 + theta * (x-x0) ) / (n+1)! * (x-x0)^(n+1)
.Ve
.PP
Please refer to your favourite book on the topic. 'theta' may be
any number between 0 and 1.
.PP
The calling conventions for TaylorErrorLagrange are similar to those of
TaylorPolynomial, but TaylorErrorLagrange takes an extra optional argument
specifying the name of 'theta'. If it isn't specified explicitly, the
variable will be named 'theta' as in the formula above.
.Sh "TaylorErrorCauchy"
.IX Subsection "TaylorErrorCauchy"
TaylorErrorCauchy computes and returns the formula for the Taylor
Polynomial's approximation error after (guess who!) Cauchy.
(Again, my English terminology is lacking.) It looks similar to this:
.PP
.Vb 1
\&  Rn(f, x, x0) = TaylorErrorLagrange(...) * (1 - theta)^n
.Ve
.PP
Please refer to your favourite book on the topic and the documentation for
TaylorErrorLagrange. 'theta' may be any number between 0 and 1.
.PP
The calling conventions for TaylorErrorCauchy are identical to those of
TaylorErrorLagrange.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send feedback, bug reports, and support requests to the Math::Symbolic
support mailing list:
math-symbolic-support at lists dot sourceforge dot net. Please
consider letting us know how you use Math::Symbolic. Thank you.
.PP
If you're interested in helping with the development or extending the
module's functionality, please contact the developers' mailing list:
math-symbolic-develop at lists dot sourceforge dot net.
.PP
List of contributors:
.PP
.Vb 3
\&  Steffen Müller, symbolic-module at steffen-mueller dot net
\&  Stray Toaster, mwk at users dot sourceforge dot net
\&  Oliver Ebenhöh
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
New versions of this module can be found on
http://steffen\-mueller.net or \s-1CPAN\s0. The module development takes place on
Sourceforge at http://sourceforge.net/projects/math\-symbolic/
.PP
Math::Symbolic
